{"version":3,"sources":["leaflet/layers/leaflet-layers.directive.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,sCAAkF;AAIlF,+DAA6D;AAE7D,+EAA4E;AAC5E,6DAA0D;AAM1D,IAAa,sBAAsB;IAQlC,gCAAY,gBAAkC;QAC7C,IAAI,CAAC,gBAAgB,GAAG,IAAI,mDAAuB,CAAC,gBAAgB,CAAC,CAAC;IACvE,CAAC;IAED,yCAAQ,GAAR;QAEC,eAAe;QACf,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC;QAE7B,mGAAmG;QACnG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;IAEjC,CAAC;IAED,4CAAW,GAAX,UAAY,OAAwC;QAEnD,iBAAiB;QACjB,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,YAAY,CAAC;YACvC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,aAAa,EAAE,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC;YAEnF,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACtB,CAAC;IAEF,CAAC;IAED;;;OAGG;IACK,0CAAS,GAAjB,UAAkB,SAAoB,EAAE,UAAqB;QAE5D,IAAI,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC;QAEzC,EAAE,CAAC,CAAC,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC;YAEjB,IAAI,IAAI,GAAG,uCAAiB,CAAC,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;YAE/D,oBAAoB;YACpB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAC,CAAC,IAAO,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAEpD,qBAAqB;YACrB,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAC,CAAC,IAAO,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAE/C,CAAC;IAEF,CAAC;IAEF,6BAAC;AAAD,CAxDA,AAwDC,IAAA;AApDwB;IAAvB,YAAK,CAAC,eAAe,CAAC;;sDAAoB;AAJ/B,sBAAsB;IAHlC,gBAAS,CAAC;QACV,QAAQ,EAAE,iBAAiB;KAC3B,CAAC;qCAS6B,oCAAgB;GARlC,sBAAsB,CAwDlC;AAxDY,wDAAsB","file":"leaflet-layers.directive.js","sourcesContent":["import { Directive, Input, OnChanges, OnInit, SimpleChange } from '@angular/core';\n\nimport * as L from 'leaflet';\n\nimport { LeafletDirective } from '../core/leaflet.directive';\n\nimport { LeafletDirectiveWrapper } from '../core/leaflet.directive.wrapper';\nimport { LeafletLayersUtil } from './leaflet-layers.util';\n\n\n@Directive({\n\tselector: '[leafletLayers]'\n})\nexport class LeafletLayersDirective\n\timplements OnChanges, OnInit {\n\n\t// Array of configured layers\n\t@Input('leafletLayers') layers: L.Layer [];\n\n\tprivate leafletDirective: LeafletDirectiveWrapper;\n\n\tconstructor(leafletDirective: LeafletDirective) {\n\t\tthis.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n\t}\n\n\tngOnInit() {\n\n\t\t// Init the map\n\t\tthis.leafletDirective.init();\n\n\t\t// The way we've set this up, map isn't set until after the first round of changes has gone through\n\t\tthis.setLayers(this.layers, []);\n\n\t}\n\n\tngOnChanges(changes: { [key: string]: SimpleChange }) {\n\n\t\t// Set the layers\n\t\tif (changes['layers']) {\n\t\t\tlet c = changes['layers'].currentValue;\n\t\t\tlet p = (changes['layers'].isFirstChange()) ? [] : changes['layers'].previousValue;\n\n\t\t\tthis.setLayers(c, p);\n\t\t}\n\n\t}\n\n\t/**\n\t * Replace the current layers in the map with the provided array\n\t * @param layers The new complete array of layers for the map\n\t */\n\tprivate setLayers(newLayers: L.Layer[], prevLayers: L.Layer[]) {\n\n\t\tlet map = this.leafletDirective.getMap();\n\n\t\tif (null != map) {\n\n\t\t\tlet diff = LeafletLayersUtil.diffLayers(newLayers, prevLayers);\n\n\t\t\t// Remove the layers\n\t\t\tdiff.remove.forEach((l) => { map.removeLayer(l); });\n\n\t\t\t// Add the new layers\n\t\t\tdiff.add.forEach((l) => { map.addLayer(l); });\n\n\t\t}\n\n\t}\n\n}\n"]}