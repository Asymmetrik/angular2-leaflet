{"version":3,"sources":["leaflet/core/leaflet.directive.ts"],"names":[],"mappings":"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","file":"leaflet.directive.js","sourcesContent":["import { Directive, ElementRef, EventEmitter, HostListener, Input, OnChanges, OnInit, Output, SimpleChange } from '@angular/core';\n\nimport * as L from 'leaflet';\n\n@Directive({\n\tselector: '[leaflet]'\n})\nexport class LeafletDirective\n\timplements OnChanges, OnInit {\n\n\treadonly DEFAULT_ZOOM = 1;\n\treadonly DEFAULT_CENTER = L.latLng([ 38.907192, -77.036871 ]);\n\treadonly DEFAULT_FPZ_OPTIONS = {};\n\n\telement: ElementRef;\n\tresizeTimer: any;\n\n\t// Reference to the primary map object\n\tmap: L.Map;\n\n\t@Input('leafletFitBoundsOptions') fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n\t@Input('leafletPanOptions') panOptions = this.DEFAULT_FPZ_OPTIONS;\n\t@Input('leafletZoomOptions') zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n\t@Input('leafletZoomPanOptions') zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n\n\n\t// Default configuration\n\t@Input('leafletOptions') options: L.MapOptions = {};\n\n\t// Configure callback function for the map\n\t@Output('leafletMapReady') mapReady = new EventEmitter<L.Map>();\n\n\t// Zoom level for the map\n\t@Input('leafletZoom') zoom: number;\n\n\t// Center the map\n\t@Input('leafletCenter') center: L.LatLng;\n\n\t// Set fit bounds for map\n\t@Input('leafletFitBounds') fitBounds: L.LatLngBounds;\n\n\n\tconstructor(el: ElementRef) {\n\t\tthis.element = el;\n\t}\n\n\tngOnInit() {\n\n\t\t// Create the map with some reasonable defaults\n\t\tthis.map = L.map(this.element.nativeElement, this.options);\n\n\t\t// Only setView if there is a center/zoom\n\t\tif (null != this.center && null != this.zoom) {\n\t\t\tthis.setView(this.center, this.zoom);\n\t\t}\n\n\t\t// Set up all the initial settings\n\t\tif (null != this.fitBounds) {\n\t\t\tthis.setFitBounds(this.fitBounds);\n\t\t}\n\n\t\tthis.doResize();\n\n\t\t// Fire map ready event\n\t\tthis.mapReady.emit(this.map);\n\n\t}\n\n\tngOnChanges(changes: { [key: string]: SimpleChange }) {\n\n\t\t/*\n\t\t * The following code is to address an issue with our (basic) implementation of\n\t\t * zooming and panning. From our testing, it seems that a pan operation followed\n\t\t * by a zoom operation in the same thread will interfere with eachother. The zoom\n\t\t * operation interrupts/cancels the pan, resulting in a final center point that is\n\t\t * inaccurate. The solution seems to be to either separate them with a timeout or\n\t\t  * to collapse them into a setView call.\n\t\t */\n\n\t\t// Zooming and Panning\n\t\tif (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n\t\t\tthis.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n\t\t}\n\t\t// Set the zoom level\n\t\telse if (changes['zoom']) {\n\t\t\tthis.setZoom(changes['zoom'].currentValue);\n\t\t}\n\t\t// Set the map center\n\t\telse if (changes['center']) {\n\t\t\tthis.setCenter(changes['center'].currentValue);\n\t\t}\n\n\t\t// Fit bounds\n\t\tif (changes['fitBounds']) {\n\t\t\tthis.setFitBounds(changes['fitBounds'].currentValue);\n\t\t}\n\n\t}\n\n\tpublic getMap() {\n\t\treturn this.map;\n\t}\n\n\n\t@HostListener('window:resize', ['$event'])\n\tonResize() {\n\t\tthis.delayResize();\n\t}\n\n\t/**\n\t * Resize the map to fit it's parent container\n\t */\n\tprivate doResize() {\n\n\t\t// Invalidate the map size to trigger it to update itself\n\t\tthis.map.invalidateSize({});\n\n\t}\n\n\t/**\n\t * Manage a delayed resize of the component\n\t */\n\tprivate delayResize() {\n\t\tif (null != this.resizeTimer) {\n\t\t\tclearTimeout(this.resizeTimer);\n\t\t}\n\t\tthis.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n\t}\n\n\n\t/**\n\t * Set the view (center/zoom) all at once\n\t * @param center The new center\n\t * @param zoom The new zoom level\n\t */\n\tprivate setView(center: L.LatLng, zoom: number) {\n\n\t\tif (this.map && null != center && null != zoom) {\n\t\t\tthis.map.setView(center, zoom, this.zoomPanOptions);\n\t\t}\n\n\t}\n\n\t/**\n\t * Set the map zoom level\n\t * @param zoom the new zoom level for the map\n\t */\n\tprivate setZoom(zoom: number) {\n\n\t\tif (this.map && null != zoom) {\n\t\t\tthis.map.setZoom(zoom, this.zoomOptions);\n\t\t}\n\n\t}\n\n\t/**\n\t * Set the center of the map\n\t * @param center the center point\n\t */\n\tprivate setCenter(center: L.LatLng) {\n\n\t\tif (this.map && null != center) {\n\t\t\tthis.map.panTo(center, this.panOptions);\n\t\t}\n\n\t}\n\n\t/**\n\t * Fit the map to the bounds\n\t * @param center the center point\n\t */\n\tprivate setFitBounds(latLngBounds: L.LatLngBounds) {\n\n\t\tif (this.map && null != latLngBounds) {\n\t\t\tthis.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n\t\t}\n\n\t}\n}\n"]}